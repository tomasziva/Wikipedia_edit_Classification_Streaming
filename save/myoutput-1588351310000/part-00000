{"title_page": "Xargs", "text_new": "{{lowercase|title=xargs}}\n'''xargs''' (short for \"eXtended ARGuments\" <ref>{{Cite web|url=http://www.roesler-ac.de/wolfram/acro/all.htm|title=The Unix Acronym List: The Complete List|website=www.roesler-ac.de|access-date=2020-04-12}}</ref>) is a [[Command (computing)|command]] on [[Unix]] and most [[Unix-like]] operating systems used to build and execute commands from [[Standard streams|standard input]]. It converts input from standard input into arguments to a command.\n\nSome commands such as <code>[[grep]]</code> and <code>[[awk]]</code> can take input either as command-line arguments or from the standard input. However, others such as <code>[[Cp (Unix)|cp]]</code> and <code>[[echo (command)|echo]]</code> can only take input as arguments, which is why '''xargs''' is necessary.\n\n==Examples==\n\nOne use case of the '''xargs''' command is to remove a list of files using the [[rm (Unix)|rm]] command. Under the [[Linux kernel]] before version 2.6.23, and under many other Unix-like systems, arbitrarily long lists of parameters cannot be passed to a command,<ref>{{cite web|url=https://www.gnu.org/software/coreutils/faq/coreutils-faq.html#Argument-list-too-long|title=GNU Core Utilities Frequently Asked Questions|publisher=|accessdate=December 7, 2015}}</ref> so the command may fail with an error message of \"Argument list too long\" (meaning that the exec system call's limit on the length of a command line was exceeded): <source lang=\"bash\" inline>rm /path/*</source> or <source lang=\"bash\" inline>rm $(find /path -type f)</source>\n\nThis can be rewritten using the <code>xargs</code> command to break the list of arguments into sublists small enough to be acceptable:\n\n<source lang=\"bash\">\nfind /path -type f -print | xargs rm\n</source>\nIn the above example, the [[Find (Unix)|<code>find</code> utility]] feeds the input of <code>xargs</code> with a long list of file names. <code>xargs</code> then splits this list into sublists and calls <code>rm</code> once for every sublist.\n\n'''xargs''' can also be used to parallelize operations with the <code>-P maxprocs</code> argument to specify how many parallel processes should be used to execute the commands over the input argument lists. However, the output streams may not be synchronized. This can be overcome by using an <code>--output file</code> argument where possible, and then combining the results after processing. The following example queues 24 processes and waits on each to finish before launching another.\n<source lang=\"bash\">\nfind /path -name '*.foo' | xargs -P 24 -I '{}' /cpu/bound/process '{}' -o '{}'.out\n</source>\n\n'''xargs''' often covers the same functionality as the <i>command substitution</i> feature of many [[Unix shell|shells]], denoted by the [[Grave accent#Use in programming|backquote]] notation (<tt>`...`</tt>).  Note that backquotes for the early evaluation of commands is now largely deprecated in favor of the <tt>$(...)</tt> notation. '''xargs''' is also a good companion for commands that output long lists of files such as <code>[[Find (Unix)|find]]</code>, <code>[[GNU locate|locate]]</code> and <code>[[grep]]</code>, but only if you use <code>-0</code> (or equivalently <code>--null</code>), since <code>xargs</code> without <code>-0</code> deals badly with file names containing <tt>'</tt>, <tt>\"</tt> and space. [[Parallel (software)|GNU Parallel]] is a similar tool that offers better compatibility with [[Find (Unix)|find]], [[GNU locate|locate]] and [[grep]] when file names may contain <tt>'</tt>, <tt>\"</tt>, and space (newline still requires <code>-0</code>).\n\n==Placement of arguments==\n===-I option===\nThe '''xargs''' command offers options to insert the listed arguments at some position other than the end of the command line. The <tt>-I</tt> option to '''xargs''' takes a string that will be replaced with the supplied input before the command is executed. A common choice is <tt>%</tt>.\n<source lang=\"shell-session\">\n$ mkdir ~/backups\n$ find /path -type f -name '*~' -print0 | xargs -0 -I % cp -a % ~/backups\n</source>\n\nThe string to replace may appear multiple times in the command part. Using {{tt|-I}} at all limits the number of lines used each time to one.\n\n===Shell trick===\nAnother way to achieve a similar effect is to use a shell as the launched command, and deal with the complexity in that shell, for example:\n<source lang=\"shell-session\">\n$ mkdir ~/backups\n$ find /path -type f -name '*~' -print0 | xargs -0 sh -c 'for filename; do cp -a \"$filename\" ~/backups; done' --\n</source>\n\nThe word {{code|--}} at the end of the line is for the [[POSIX shell]] {{code|sh -c}} to start recognizing the positional parameter (argv) {{code|$1}}. If it weren't present, the name of the first matched file would be assigned to <code>$0</code>, the \"executable name\" part of the {{code|argv}} and the file wouldn't be copied to <code>~/backups</code>. One can also use any other word to fill in that blank.\n\nSince {{code|cp}} accepts multiple files at once, one can also simply do the following:\n<source lang=\"shell-session\">\n$ find /path -type f -name '*~' -print0 | xargs -0 sh -c 'if [ $# -gt 0 ]; then cp -a \"$@\" ~/backup; fi' --\n</source>\nThis script runs {{code|cp}} with all the files given to it when there are any arguments passed. Doing so is more efficient since only one invocation of {{code|cp}} is done for each invocation of {{code|sh}}.\n\n==Separator problem==\nMany Unix utilities are line-oriented. These may work with <code>xargs</code> as long as the lines do not contain <code>'</code>, <code>\"</code>, or a space. Some of the Unix utilities can use [[Null character|NUL]] as record separator (e.g. [[Perl]] (requires <code>-0</code> and <code>\\0</code> instead of <code>\\n</code>), <code>[[Locate (Unix)|locate]]</code> (requires using <code>-0</code>), <code>[[Find (Unix)|find]]</code> (requires using <code>-print0</code>), <code>[[grep]]</code> (requires <code>-z</code> or <code>-Z</code>), <code>[[Sort (Unix)|sort]]</code> (requires using <code>-z</code>)). Using <code>-0</code> for <code>xargs</code> deals with the problem, but many Unix utilities cannot use NUL as separator (e.g. <code>[[head (Unix)|head]]</code>, <code>[[tail (Unix)|tail]]</code>, <code>[[ls]]</code>, <code>[[echo (command)|echo]]</code>, <code>[[sed]]</code>, <code>[[tar (file format)|tar]] -v</code>, <code>[[wc (Unix)|wc]]</code>, <code>[[which (command)|which]]</code>).\n\nBut often people forget this and assume <code>xargs</code> is also line-oriented, which is '''not''' the case (per default <code>xargs</code> separates on newlines '''and''' blanks within lines, substrings with blanks must be single- or double-quoted).\n\nThe separator problem is illustrated here:\n<source lang=\"bash\">\n# Make some targets to practice on\ntouch important_file\ntouch 'not important_file'\nmkdir -p '12\" records'\n\nfind . -name not\\* | tail -1 | xargs rm\nfind \\! -name . -type d | tail -1 | xargs rmdir\n</source>\nRunning the above will cause <code>important_file</code> to be removed but will remove neither the directory called <code>12\" records</code>, nor the file called <code>not important_file</code>.\n\nThe proper fix is to use the GNU-specific <code>-print0</code> option, but <code>tail</code> (and other tools) do not support NUL-terminated strings:\n<source lang=\"bash\">\n# use the same preparation commands as above\nfind . -name not\\* -print0 | xargs -0 rm\nfind \\! -name . -type d -print0 | xargs -0 rmdir\n</source>\n\nWhen using the <code>-print0</code> option, entries are separated by a null character instead of an end-of-line. This is equivalent to the more verbose command:<source lang=\"bash\" inline>find . -name not\\* | tr \\\\n \\\\0 | xargs -0 rm</source> or shorter, by switching <code>xargs</code> to (non-POSIX) '''line-oriented mode''' with the <code>-d</code> (delimiter) option: <source lang=\"bash\" inline>find . -name not\\* | xargs -d '\\n' rm</source>\n\nbut in general using <code>-0</code> with <code>-print0</code> should be preferred, since newlines in filenames are still a problem.\n\nGNU <code>[[GNU parallel|parallel]]</code> is an alternative to <code>xargs</code> that is designed to have the same options, but is line-oriented. Thus, using GNU Parallel instead, the above would work as expected.<ref>[https://www.gnu.org/software/parallel/man.html#differences_between_xargs_and_gnu_parallel Differences Between xargs and GNU Parallel]. [http://www.gnu.org GNU.org]. Accessed February 2012.</ref>\n\nFor Unix environments where <code>xargs</code> does not support the <code>-0</code> nor the {{code|-d}} option (e.g. Solaris, AIX), the POSIX standard states that one can simply backslash-escape every character:<source lang=\"bash\" inline>find . -name not\\* | sed 's/\\(.\\)/\\\\\\1/g' | xargs rm</source>.<ref>{{man|1|xargs|SUS}}</ref> Alternatively, one can avoid using xargs at all, either by using GNU parallel or using the {{code|-exec ... +}} functionality of {{code|find}}.\n\n==Operating on a subset of arguments at a time==\nOne might be dealing with commands that can only accept one or maybe two arguments at a time. For example, the <code>diff</code> command operates on two files at a time. The <code>-n</code> option to <code>xargs</code> specifies how many arguments at a time to supply to the given command. The command will be invoked repeatedly until all input is exhausted. Note that on the last invocation one might get fewer than the desired number of arguments if there is insufficient input. Use <code>xargs</code> to break up the input into two arguments per line:\n<source lang=\"shell-session\">\n$ echo {0..9} | xargs -n 2\n0 1\n2 3\n4 5\n6 7\n8 9\n</source>\n\nIn addition to running based on a specified number of arguments at a time, one can also invoke a command for each line of input with the <code>-L 1</code> option. One can use an arbitrary number of lines at a time, but one is most common. Here is how one might <code>diff</code> every git commit against its parent.<ref>{{cite web|url=http://offbytwo.com/2011/06/26/things-you-didnt-know-about-xargs.html|title=Things you (probably) didn't know about xargs|author=Cosmin Stejerean|publisher=|accessdate=December 7, 2015}}</ref>\n<source lang=\"shell-session\">\n$ git log --format=\"%H %P\" | xargs -L 1 git diff\n</source>\n\n==Encoding problem==\nThe argument separator processing of <code>xargs</code> is not the only problem with using the <code>xargs</code> program in its default mode. Most Unix tools which are often used to manipulate filenames (for example <code>sed</code>, <code>basename</code>, <code>sort</code>, etc.) are text processing tools. However, Unix path names are not really text. Consider a path name /aaa/bbb/ccc. The /aaa directory and its bbb subdirectory can in general be created by different users with different environments. That means these users could have a different locale setup, and that means that aaa and bbb do not even necessarily have to have the same character encoding. For example, aaa could be in UTF-8 and bbb in Shift JIS. As a result, an absolute path name in a Unix system may not be correctly processable as text under a single character encoding. Tools which rely on their input being text may fail on such strings.\n\nOne workaround for this problem is to run such tools in the C locale, which essentially processes the bytes of the input as-is. However, this will change the behavior of the tools in ways the user may not expect (for example, some of the user's expectations about case-folding behavior may not be met).\n\n==References==\n{{reflist}}\n\n==External links==\n* {{man|cu|xargs|SUS|construct argument lists and invoke utility}}\n* [https://www.poftut.com/linux-xargs-command-tutorial-with-examples/ Linux Xargs Command Tutorial With Examples]\n\n===Manual pages===\n* {{man/format|1|xargs|https://www.gnu.org/software/findutils/manual/html_node/find_html/Invoking-xargs.html||[[GNU]] [[Findutils]] reference}}\n* {{man|1|xargs|FreeBSD|construct argument list(s) and execute utility}}\n* {{man|1|xargs|NetBSD|construct argument list(s) and execute utility}}\n* {{man|1|xargs|OpenBSD|construct argument list(s) and execute utility}}\n* {{man|1|xargs|Solaris|construct argument lists and invoke utility}}\n\n{{unix commands}}\n\n[[Category:Unix text processing utilities]]\n[[Category:Unix SUS2008 utilities]]\n", "text_old": "{{lowercase|title=xargs}}\n'''xargs''' (short for \"eXtended ARGuments\" <ref>{{Cite web|url=http://www.roesler-ac.de/wolfram/acro/all.htm|title=The Unix Acronym List: The Complete List|website=www.roesler-ac.de|access-date=2020-04-12}}</ref>) is a [[Command (computing)|command]] on [[Unix]] and most [[Unix-like]] operating systems used to build and execute commands from [[Standard streams|standard input]]. It converts input from standard input into arguments to a command.\n\nSome commands such as <code>[[grep]]</code> and <code>[[awk]]</code> can take input either as command-line arguments or from the standard input. However, others such as <code>[[Cp (Unix)|cp]]</code> and <code>[[echo (command)|echo]]</code> can only take input as arguments, which is why '''xargs''' is necessary.\n\n==Examples==\n\nOne use case of the '''xargs''' command is to remove a list of files using the [[rm (Unix)|rm]] command. Under the [[Linux kernel]] before version 2.6.23, and under many other Unix-like systems, arbitrarily long lists of parameters cannot be passed to a command,<ref>{{cite web|url=https://www.gnu.org/software/coreutils/faq/coreutils-faq.html#Argument-list-too-long|title=GNU Core Utilities Frequently Asked Questions|publisher=|accessdate=December 7, 2015}}</ref> so the command may fail with an error message of \"Argument list too long\" (meaning that the exec system call's limit on the length of a command line was exceeded):\n\n<source lang=\"bash\" inline>rm /path/*</source> or <source lang=\"bash\" inline>rm $(find /path -type f)</source>\n\nThis can be rewritten using the <code>xargs</code> command to break the list of arguments into sublists small enough to be acceptable:\n\n<source lang=\"bash\">\nfind /path -type f -print | xargs rm\n</source>\nIn the above example, the [[Find (Unix)|<code>find</code> utility]] feeds the input of <code>xargs</code> with a long list of file names. <code>xargs</code> then splits this list into sublists and calls <code>rm</code> once for every sublist.\n\n'''xargs''' can also be used to parallelize operations with the <code>-P maxprocs</code> argument to specify how many parallel processes should be used to execute the commands over the input argument lists. However, the output streams may not be synchronized. This can be overcome by using an <code>--output file</code> argument where possible, and then combining the results after processing. The following example queues 24 processes and waits on each to finish before launching another.\n<source lang=\"bash\">\nfind /path -name '*.foo' | xargs -P 24 -I '{}' /cpu/bound/process '{}' -o '{}'.out\n</source>\n\n'''xargs''' often covers the same functionality as the <i>command substitution</i> feature of many [[Unix shell|shells]], denoted by the [[Grave accent#Use in programming|backquote]] notation (<tt>`...`</tt>).  Note that backquotes for the early evaluation of commands is now largely deprecated in favor of the <tt>$(...)</tt> notation. '''xargs''' is also a good companion for commands that output long lists of files such as <code>[[Find (Unix)|find]]</code>, <code>[[GNU locate|locate]]</code> and <code>[[grep]]</code>, but only if you use <code>-0</code> (or equivalently <code>--null</code>), since <code>xargs</code> without <code>-0</code> deals badly with file names containing <tt>'</tt>, <tt>\"</tt> and space. [[Parallel (software)|GNU Parallel]] is a similar tool that offers better compatibility with [[Find (Unix)|find]], [[GNU locate|locate]] and [[grep]] when file names may contain <tt>'</tt>, <tt>\"</tt>, and space (newline still requires <code>-0</code>).\n\n==Placement of arguments==\n===-I option===\nThe '''xargs''' command offers options to insert the listed arguments at some position other than the end of the command line. The <tt>-I</tt> option to '''xargs''' takes a string that will be replaced with the supplied input before the command is executed. A common choice is <tt>%</tt>.\n<source lang=\"shell-session\">\n$ mkdir ~/backups\n$ find /path -type f -name '*~' -print0 | xargs -0 -I % cp -a % ~/backups\n</source>\n\nThe string to replace may appear multiple times in the command part. Using {{tt|-I}} at all limits the number of lines used each time to one.\n\n===Shell trick===\nAnother way to achieve a similar effect is to use a shell as the launched command, and deal with the complexity in that shell, for example:\n<source lang=\"shell-session\">\n$ mkdir ~/backups\n$ find /path -type f -name '*~' -print0 | xargs -0 sh -c 'for filename; do cp -a \"$filename\" ~/backups; done' --\n</source>\n\nThe word {{code|--}} at the end of the line is for the [[POSIX shell]] {{code|sh -c}} to start recognizing the positional parameter (argv) {{code|$1}}. If it weren't present, the name of the first matched file would be assigned to <code>$0</code>, the \"executable name\" part of the {{code|argv}} and the file wouldn't be copied to <code>~/backups</code>. One can also use any other word to fill in that blank.\n\nSince {{code|cp}} accepts multiple files at once, one can also simply do the following:\n<source lang=\"shell-session\">\n$ find /path -type f -name '*~' -print0 | xargs -0 sh -c 'if [ $# -gt 0 ]; then cp -a \"$@\" ~/backup; fi' --\n</source>\nThis script runs {{code|cp}} with all the files given to it when there are any arguments passed. Doing so is more efficient since only one invocation of {{code|cp}} is done for each invocation of {{code|sh}}.\n\n==Separator problem==\nMany Unix utilities are line-oriented. These may work with <code>xargs</code> as long as the lines do not contain <code>'</code>, <code>\"</code>, or a space. Some of the Unix utilities can use [[Null character|NUL]] as record separator (e.g. [[Perl]] (requires <code>-0</code> and <code>\\0</code> instead of <code>\\n</code>), <code>[[Locate (Unix)|locate]]</code> (requires using <code>-0</code>), <code>[[Find (Unix)|find]]</code> (requires using <code>-print0</code>), <code>[[grep]]</code> (requires <code>-z</code> or <code>-Z</code>), <code>[[Sort (Unix)|sort]]</code> (requires using <code>-z</code>)). Using <code>-0</code> for <code>xargs</code> deals with the problem, but many Unix utilities cannot use NUL as separator (e.g. <code>[[head (Unix)|head]]</code>, <code>[[tail (Unix)|tail]]</code>, <code>[[ls]]</code>, <code>[[echo (command)|echo]]</code>, <code>[[sed]]</code>, <code>[[tar (file format)|tar]] -v</code>, <code>[[wc (Unix)|wc]]</code>, <code>[[which (command)|which]]</code>).\n\nBut often people forget this and assume <code>xargs</code> is also line-oriented, which is '''not''' the case (per default <code>xargs</code> separates on newlines '''and''' blanks within lines, substrings with blanks must be single- or double-quoted).\n\nThe separator problem is illustrated here:\n<source lang=\"bash\">\n# Make some targets to practice on\ntouch important_file\ntouch 'not important_file'\nmkdir -p '12\" records'\n\nfind . -name not\\* | tail -1 | xargs rm\nfind \\! -name . -type d | tail -1 | xargs rmdir\n</source>\nRunning the above will cause <code>important_file</code> to be removed but will remove neither the directory called <code>12\" records</code>, nor the file called <code>not important_file</code>.\n\nThe proper fix is to use the GNU-specific <code>-print0</code> option, but <code>tail</code> (and other tools) do not support NUL-terminated strings:\n<source lang=\"bash\">\n# use the same preparation commands as above\nfind . -name not\\* -print0 | xargs -0 rm\nfind \\! -name . -type d -print0 | xargs -0 rmdir\n</source>\n\nWhen using the <code>-print0</code> option, entries are separated by a null character instead of an end-of-line. This is equivalent to the more verbose command:<source lang=\"bash\" inline>find . -name not\\* | tr \\\\n \\\\0 | xargs -0 rm</source> or shorter, by switching <code>xargs</code> to (non-POSIX) '''line-oriented mode''' with the <code>-d</code> (delimiter) option: <source lang=\"bash\" inline>find . -name not\\* | xargs -d '\\n' rm</source>\n\nbut in general using <code>-0</code> with <code>-print0</code> should be preferred, since newlines in filenames are still a problem.\n\nGNU <code>[[GNU parallel|parallel]]</code> is an alternative to <code>xargs</code> that is designed to have the same options, but is line-oriented. Thus, using GNU Parallel instead, the above would work as expected.<ref>[https://www.gnu.org/software/parallel/man.html#differences_between_xargs_and_gnu_parallel Differences Between xargs and GNU Parallel]. [http://www.gnu.org GNU.org]. Accessed February 2012.</ref>\n\nFor Unix environments where <code>xargs</code> does not support the <code>-0</code> nor the {{code|-d}} option (e.g. Solaris, AIX), the POSIX standard states that one can simply backslash-escape every character:<source lang=\"bash\" inline>find . -name not\\* | sed 's/\\(.\\)/\\\\\\1/g' | xargs rm</source>.<ref>{{man|1|xargs|SUS}}</ref> Alternatively, one can avoid using xargs at all, either by using GNU parallel or using the {{code|-exec ... +}} functionality of {{code|find}}.\n\n==Operating on a subset of arguments at a time==\nOne might be dealing with commands that can only accept one or maybe two arguments at a time. For example, the <code>diff</code> command operates on two files at a time. The <code>-n</code> option to <code>xargs</code> specifies how many arguments at a time to supply to the given command. The command will be invoked repeatedly until all input is exhausted. Note that on the last invocation one might get fewer than the desired number of arguments if there is insufficient input. Use <code>xargs</code> to break up the input into two arguments per line:\n<source lang=\"shell-session\">\n$ echo {0..9} | xargs -n 2\n0 1\n2 3\n4 5\n6 7\n8 9\n</source>\n\nIn addition to running based on a specified number of arguments at a time, one can also invoke a command for each line of input with the <code>-L 1</code> option. One can use an arbitrary number of lines at a time, but one is most common. Here is how one might <code>diff</code> every git commit against its parent.<ref>{{cite web|url=http://offbytwo.com/2011/06/26/things-you-didnt-know-about-xargs.html|title=Things you (probably) didn't know about xargs|author=Cosmin Stejerean|publisher=|accessdate=December 7, 2015}}</ref>\n<source lang=\"shell-session\">\n$ git log --format=\"%H %P\" | xargs -L 1 git diff\n</source>\n\n==Encoding problem==\nThe argument separator processing of <code>xargs</code> is not the only problem with using the <code>xargs</code> program in its default mode. Most Unix tools which are often used to manipulate filenames (for example <code>sed</code>, <code>basename</code>, <code>sort</code>, etc.) are text processing tools. However, Unix path names are not really text. Consider a path name /aaa/bbb/ccc. The /aaa directory and its bbb subdirectory can in general be created by different users with different environments. That means these users could have a different locale setup, and that means that aaa and bbb do not even necessarily have to have the same character encoding. For example, aaa could be in UTF-8 and bbb in Shift JIS. As a result, an absolute path name in a Unix system may not be correctly processable as text under a single character encoding. Tools which rely on their input being text may fail on such strings.\n\nOne workaround for this problem is to run such tools in the C locale, which essentially processes the bytes of the input as-is. However, this will change the behavior of the tools in ways the user may not expect (for example, some of the user's expectations about case-folding behavior may not be met).\n\n==References==\n{{reflist}}\n\n==External links==\n* {{man|cu|xargs|SUS|construct argument lists and invoke utility}}\n* [https://www.poftut.com/linux-xargs-command-tutorial-with-examples/ Linux Xargs Command Tutorial With Examples]\n\n===Manual pages===\n* {{man/format|1|xargs|https://www.gnu.org/software/findutils/manual/html_node/find_html/Invoking-xargs.html||[[GNU]] [[Findutils]] reference}}\n* {{man|1|xargs|FreeBSD|construct argument list(s) and execute utility}}\n* {{man|1|xargs|NetBSD|construct argument list(s) and execute utility}}\n* {{man|1|xargs|OpenBSD|construct argument list(s) and execute utility}}\n* {{man|1|xargs|Solaris|construct argument lists and invoke utility}}\n\n{{unix commands}}\n\n[[Category:Unix text processing utilities]]\n[[Category:Unix SUS2008 utilities]]\n", "name_user": "Artoria2e5", "label": "safe", "comment": "\u2192\u200eExamples", "url_page": "//en.wikipedia.org/wiki/Xargs"}
