{"title_page": "Binary recompiler", "text_new": "A '''binary recompiler''' is a [[compiler]] that takes [[executable]] [[binary file]]s as input, analyzes their structure, applies transformations and optimizations, and outputs new optimized executable binaries.<ref name=\"Mudge\"/>\n\nThe foundation to the concepts of binary recompilation were laid out by [[Gary Kildall]]<ref name=\"Kildall_1972_Optimization\"/><ref name=\"Kildall_1973_Optimization\"/><ref name=\"Freiberger_1981_Translators\"/><ref name=\"Wharton_1994\"/><ref name=\"SPA_1995\"/><ref name=\"Swaine_1997\"/><ref name=\"Laws_2014_IEEE\"/> with the development of the optimizing [[assembly code translator]] [[XLT86]] in 1981.<ref name=\"Freiberger_1981_Translators\"/><ref name=\"Barry_1982_XLT86\"/><ref name=\"Swaine_1982_CPM\"/><ref name=\"Bunnell_1982_CPM\"/>\n\n==See also==\n* [[Binary optimizer]] (binary-to-binary)\n* [[Binary translator]] (binary-to-binary)\n* [[Decompiler]] (binary-to-source)\n* [[Disassembler]] (binary-to-source)\n* [[Dynamic recompiler]] (binary-to-binary)\n* [[Transcompiler]] (source-to-source)\n* [[Honeywell Liberator]] (running [[IBM 1401]] programs on [[Honeywell H200]])\n\n==References==\n{{Reflist|refs=\n<ref name=\"Mudge\">{{cite web |author-first1=Trevor |author-last1=Mudge |author-first2=Steve |author-last2=Reinhardt |author-first3=Gary |author-last3=Tyson |url=http://web.eecs.umich.edu/~jringenb/binary_recomp.html |access-date=2012-07-23 |website=umich.edu |title=Binary Recompilation and Combined Compiler/Architecture Enhancements Studies |publisher=[[University of Michigan]] (UM) |url-status=dead |archive-url=https://web.archive.org/web/20120723224028/http://web.eecs.umich.edu/~jringenb/binary_recomp.html |archive-date=2012-07-23}}</ref>\n<ref name=\"Kildall_1972_Optimization\">{{Cite book |title=Global expression optimization during compilation |author-first=Gary Arlen |author-last=Kildall |author-link=Gary Arlen Kildall |type=Ph.D. dissertation |publisher=[[University of Washington]], Computer Science Group |location=Seattle, Washington, USA |date=May 1972 |id=Thesis No. 20506, Technical Report No. 72-06-02}}</ref> \n<ref name=\"Kildall_1973_Optimization\">{{Cite journal |author-first=Gary Arlen |author-last=Kildall |author-link=Gary Kildall |date=1973-10-01 |title=A Unified Approach to Global Program Optimization |journal=Proceedings of the 1st Annual [[Association for Computing Machinery|ACM]] [[SIGACT]]-[[SIGPLAN]] [[Symposium on Principles of Programming Languages]] (POPL) |series=POPL '73 |location=Boston, Massachusetts, USA |pages=194\u2013206 |doi=10.1145/512927.512945 |hdl=10945/42162 |url=http://static.aminer.org/pdf/PDF/000/546/451/a_unified_approach_to_global_program_optimization.pdf |access-date=2006-11-20 |url-status=live |archive-url=https://web.archive.org/web/20170629213307/http://static.aminer.org/pdf/PDF/000/546/451/a_unified_approach_to_global_program_optimization.pdf |archive-date=2017-06-29}} ([http://portal.acm.org/citation.cfm?id=512945&coll=portal&dl=ACM])</ref>\n<ref name=\"Freiberger_1981_Translators\">{{cite newspaper |title=Program translators do it literally - and sometimes in context |author-first=Paul |author-last=Freiberger |author-link=Paul Freiberger |series=Special section: Computer compatibility |newspaper=[[InfoWorld]] - News For Microcomputer Users |issn=0199-6649 |publisher=[[Popular Computing, Inc.]] |date=1981-10-19 |volume=3 |issue=22 |page=19 |url=https://books.google.com/books?id=Gj0EAAAAMBAJ&pg=PA19&lpg=PA19 |access-date=2020-01-15 |url-status=live |archive-url= |archive-date= |quote=[\u2026] \"Unless you have a translating scheme that takes account of the peculiar idiosyncrasies of the target microprocessor, there is no way that an automatic translator can work,\" explains Daniel Davis, a programmer with [[Digital Research]]. \"You'll end up with direct [[transliteration]]s.\" [\u2026] In spite of all these limitations, progress has been made recently in the development of translators. Most notably, Digital Research has introduced its eight- to 16-bit assembly code translator. Based on research performed by Digital Research president [[Gary Arlen Kildall|Gary Kildall]], the [[XLT86]] appears to offer advances over previously available software translator technology. Like [[Sorcim]]'s [[Sorcim TRANS86|Trans]] and [[Intel]]'s [[Convert&nbsp;86]], Kildall's package translates assembly-language code from an [[8080]] microprocessor to an [[8086]]. However, Kildall has applied a [[global data flow analysis|global flow analysis]] technique that takes into account some of the major drawbacks of other translators. The procedure analyzes the register and flag usage in sections of 8080 code in order to eliminate [[nonessential code]]. According to Digital Research programmer Davis, the algorithm Kildall uses allows the translator to consider the context as it translates the program. Until now, one of the major problems with any translator program has been the inability of the software to do much more than transliteration. If Digital Research's new translator actually advances the technology to the point where context can be considered, then more software translators may proliferate in the microcomputer marketplace.}}</ref>\n<ref name=\"Barry_1982_XLT86\">{{cite newspaper |title=XLT-86, a CP/M utility program by Digital Research |author-first=Tim |author-last=Barry |series=InfoWorld Software Review |newspaper=[[InfoWorld]] - The Newsweekly for Microcomputer Users |issn=0199-6649 |publisher=[[Popular Computing, Inc.]] |date=1982-04-05 |volume=4 |issue=13 |pages=40\u201341, 53 |url=https://books.google.com/books?id=ZjAEAAAAMBAJ&pg=PA40&lpg=PA41 |access-date=2020-01-25 |url-status=live |archive-url= |archive-date= |quote=[\u2026] [[XLT-86]] is an analytical translator program written in [[PL/I-80]]. It reads the entire [[8080]] source program, assembles it to [[machine code]], analyzes the register, memory and flag utilization, and emits an optimized [[8086]] assembly-language program. [\u2026] The program translation proceeds in a five-step process. First, the program is scanned and assembled to produce symbol values and locations. Second, the program structure is analyzed and decomposed into [[basic block]]s. Third, the basic blocks are analyzed to determine [[program flow]] and resource usage. Forth, the [[block (programming)|block structure]] and [[register allocation]] data is gathered into a listing for the user. Fifth, the flow information and source program are used to produce the 8086 source program. [\u2026]}}</ref>\n<ref name=\"Swaine_1982_CPM\">{{cite newspaper |title=Digital Research founder discusses his view of the business |series=Special section: CP/M |editor-first1=Michael |editor-last1=Swaine |editor-link1=Michael Swaine (technical author) |editor-first2=Paul |editor-last2=Freiberger |editor-link2=Paul Freiberger |editor-first3=John Gregory |editor-last3=Markoff |editor-link3=John Gregory Markoff |author-first=Gary Arlen |author-last=Kildall |author-link=Gary Arlen Kildall |date=1982-04-19 |newspaper=[[InfoWorld]] - The Newsweekly for Microcomputer Users |issn=0199-6649 |publisher=[[Popular Computing, Inc.]] |volume=4 |issue=15 |page=23\u201324 |url=https://books.google.com/books?id=YzAEAAAAMBAJ&pg=PA23&lpg=PA23 |access-date=2020-01-17 |url-status=live |archive-url= |archive-date= |quote=[\u2026] Kildall: [\u2026] A year and a half ago I was probably spending 75% of my time on the business and 25% on programming. [[XLT-86]] was a product I was working on at that time, and it took me nine months to do it. That would have been a three-month project if I had been able to concentrate on it. [\u2026]}}</ref>\n<ref name=\"Bunnell_1982_CPM\">{{cite magazine |title=Gary Kildall - The Man Who Created CP/M: CP/M's Creator - An Indepth PC-Exclusive Interview with Software Pioneer Gary Kildall |series=Operating Systems |editor-first1=David Hugh |editor-last1=Bunnell |editor-link=David Hugh Bunnell |editor-first2=Jim |editor-last2=Edlin |author-first=Gary Arlen |author-last=Kildall |author-link=Gary Arlen Kildall |date=June\u2013July 1982 |magazine=[[PC Magazine]] |publisher=[[Software Communications, Inc.]] |issn=<!-- not assigned at this time, but already applied for --> |volume=1 |number=3 |pages=32\u201338, 40<!-- quote taken from page 35 --> |url=https://archive.org/stream/PC-Mag-1982-06/PC-Mag-1982-06_djvu.txt |access-date=2020-01-17 |url-status=live |archive-url= |archive-date= |quote=[\u2026] PC: What are some of the complexities involved in translating a program from [[8080]] to [[8086]] form? [[Gary Arlen Kildall|Kildall]]: Straight [[assembly code translator|translations at the source program level]] you can do pretty much mechanically. For example, an 8080 \"Add immediate 5\" instruction turns into an \"Add AL 5\" on the 8086 \u2014 very straightforward translation of the op codes themselves. The complexity in [[mechanical translation]] comes from situations such as this: The 8080 instruction DAD H takes the HL register and adds DE to it. For the 8086 the equivalent instruction would be something like ADD DX BX, which is fine, no particular problem. You just say the DX register is the same as HL and BX the same as DE. The problem is that the 8086 instruction has a side effect of setting the zero flag, and the 8080 instruction does not. In mechanical translation you end up doing something like saving the flags, restoring the flags, doing some shifts and rotates, and so forth. These add about five or six extra instructions to get the same semantic effect. There are a lot of sequences in 8080 code that produce very strange sequences in 8086 code; they just don't map very well because of flag registers and things of that sort. The way we get software over is a thing called [[XLT-86]]. It's been out six months or so. PC: By \"better\" code do you mean smaller? Kildall: Twenty percent smaller than if you just took every op code and did a straight translation, saving the registers to preserve semantics. PC: How does the size of the translated program compare to the 8080 version? Kildall: If you take an 8080 program, move it over to 86 land and do an XLT-86 translation, you'll find that it is roughly 10 to 20 percent larger. With 16-bit machines it's more difficult to address everything; you get op codes that are a little bit bigger on the average. An interesting phenomenon is that one of the reasons you don't get a tremendous speed increase in the 16-bit world is because you're running more op codes over the data bus. [\u2026]}}</ref>\n<ref name=\"Wharton_1994\">{{Cite journal |url=http://tech-insider.org/personal-computers/research/1994/0801.html |access-date=2016-11-18 |title=Gary Kildall, industry pioneer, dead at 52: created first microcomputer languages, disk operating systems |journal=[[Microprocessor Report]] |publisher=[[MicroDesign Resources Inc.]] (MDR) |author-first=John Harrison |author-last=Wharton |author-link=John Harrison Wharton |volume=8 |number=10 |date=1994-08-01 |url-status=live |archive-url=https://web.archive.org/web/20161118222925/http://tech-insider.org/personal-computers/research/1994/0801.html |archive-date=2016-11-18}}</ref>\n<ref name=\"SPA_1995\">{{cite web |title=SPA Award to Dr. Gary A. Kildall: 1995 SPA Lifetime Achievement Award Winner |date=1995-03-13 |publisher=[[Software Publishers Association]] (SPA) |via=www.digitalresearch.biz |url=https://www.digitalresearch.biz/kildallr.htm |access-date=2019-12-21 |url-status=live |archive-url=http://archive.today/a3iF6 |archive-date=2019-12-21}}</ref>\n<ref name=\"Swaine_1997\">{{cite journal |author-first=Michael |author-last=Swaine |author-link=Michael Swaine (technical author) |date=1997-04-01 |title=Gary Kildall and Collegial Entrepreneurship |journal=[[Dr. Dobb's Journal]] |url=http://www.drdobbs.com/architecture-and-design/gary-kildall-and-collegial-entrepreneurs/184410428 |access-date=2006-11-20 |archive-url=https://web.archive.org/web/20070124184442/http://www.ddj.com/184410428 |archive-date=2007-01-24 |quote=In March, 1995, the [[Software Publishers Association]] posthumously honored [[Gary Kildall|Gary]] for his contributions to the computer industry. They listed some of his accomplishments: [\u2026] In the 1980s, through [[Digital Research, Inc.|DRI]], he introduced a binary recompiler. [\u2026]}}</ref>\n<ref name=\"Laws_2014_IEEE\">{{Cite web |title=Legacy of Gary Kildall: The CP/M IEEE Milestone Dedication |author-first1=Robert |author-last1=Huitt |author-first2=Gordon |author-last2=Eubanks |author-link2=Gordon Eubanks |author-first3=Thomas \"Tom\" Alan |author-last3=Rolander |author-link3=Thomas Alan Rolander |author-first4=David |author-last4=Laws |author-first5=Howard E. |author-last5=Michel |author-first6=Brian |author-last6=Halla |author-first7=John Harrison |author-last7=Wharton |author-link7=John Harrison Wharton |author-first8=Brian |author-last8=Berg |author-first9=Weilian |author-last9=Su |author-first10=Scott |author-last10=Kildall |author-link10=Scott Kildall |author-first11=Bill |author-last11=Kampe |editor-first=David |editor-last=Laws |date=2014-04-25 |location=Pacific Grove, California, USA |type=video transscription |id=CHM Reference number: X7170.2014 |publisher=[[Computer History Museum]] |url=https://archive.computerhistory.org/resources/access/text/2014/06/102746909-05-01-acc.pdf |access-date=2020-01-19 |url-status=live |archive-url= |archive-date= |quote=[\u2026] [[Thomas Alan Rolander|Rolander]]: I mentioned earlier that [[Gary Arlen Kildall|Gary]] liked to approach a problem as an architect. [\u2026] And he would draw the most beautiful pictures of his data structures. [\u2026] And when he finished that [\u2026] and was convinced those data structures were now correct, he would go into just an unbelievable manic coding mode. He would just go for as many as 20 hours a day [\u2026] he was just gone during these periods of time. On a couple of those occasions, when he'd get something running the first time, which could be in the middle of night. And all you who have written software have seen that, for example, that the first time it comes up on the screen, you\u2019ve got to tell somebody. My wife Lori will tell you that I had a couple of those calls in the middle of the night, [[DR LOGO|LOGO]] was one example, [[XLT&nbsp;86]] was another, where he got it running the first time, and he had to have somebody see it. So it didn't matter what time it was, he'd call me, I'd have to come over and see it running. [\u2026]}} [https://ethw.org/Milestones:The_CP/M_Microcomputer_Operating_System,_1974][https://www.youtube.com/watch?v=HO6IPpL0y8g] (33 pages)</ref>\n}}\n\n[[Category:Compilers|*]]\n[[Category:Compiler construction]]\n[[Category:Computer libraries]]\n", "text_old": "A '''binary recompiler''' is a [[compiler]] that takes [[executable]] [[binary file]]s as input, analyzes their structure, applies transformations and optimizations, and outputs new optimized executable binaries.<ref name=\"Mudge\"/>\n\nThe foundation to the concepts of binary recompilation were layed out by [[Gary Kildall]]<ref name=\"Kildall_1972_Optimization\"/><ref name=\"Kildall_1973_Optimization\"/><ref name=\"Freiberger_1981_Translators\"/><ref name=\"Wharton_1994\"/><ref name=\"SPA_1995\"/><ref name=\"Swaine_1997\"/><ref name=\"Laws_2014_IEEE\"/> with the development of the optimizing [[assembly code translator]] [[XLT86]] in 1981.<ref name=\"Freiberger_1981_Translators\"/><ref name=\"Barry_1982_XLT86\"/><ref name=\"Swaine_1982_CPM\"/><ref name=\"Bunnell_1982_CPM\"/>\n\n==See also==\n* [[Binary optimizer]] (binary-to-binary)\n* [[Binary translator]] (binary-to-binary)\n* [[Decompiler]] (binary-to-source)\n* [[Disassembler]] (binary-to-source)\n* [[Dynamic recompiler]] (binary-to-binary)\n* [[Transcompiler]] (source-to-source)\n* [[Honeywell Liberator]] (running [[IBM 1401]] programs on [[Honeywell H200]])\n\n==References==\n{{Reflist|refs=\n<ref name=\"Mudge\">{{cite web |author-first1=Trevor |author-last1=Mudge |author-first2=Steve |author-last2=Reinhardt |author-first3=Gary |author-last3=Tyson |url=http://web.eecs.umich.edu/~jringenb/binary_recomp.html |access-date=2012-07-23 |website=umich.edu |title=Binary Recompilation and Combined Compiler/Architecture Enhancements Studies |publisher=[[University of Michigan]] (UM) |url-status=dead |archive-url=https://web.archive.org/web/20120723224028/http://web.eecs.umich.edu/~jringenb/binary_recomp.html |archive-date=2012-07-23}}</ref>\n<ref name=\"Kildall_1972_Optimization\">{{Cite book |title=Global expression optimization during compilation |author-first=Gary Arlen |author-last=Kildall |author-link=Gary Arlen Kildall |type=Ph.D. dissertation |publisher=[[University of Washington]], Computer Science Group |location=Seattle, Washington, USA |date=May 1972 |id=Thesis No. 20506, Technical Report No. 72-06-02}}</ref> \n<ref name=\"Kildall_1973_Optimization\">{{Cite journal |author-first=Gary Arlen |author-last=Kildall |author-link=Gary Kildall |date=1973-10-01 |title=A Unified Approach to Global Program Optimization |journal=Proceedings of the 1st Annual [[Association for Computing Machinery|ACM]] [[SIGACT]]-[[SIGPLAN]] [[Symposium on Principles of Programming Languages]] (POPL) |series=POPL '73 |location=Boston, Massachusetts, USA |pages=194\u2013206 |doi=10.1145/512927.512945 |hdl=10945/42162 |url=http://static.aminer.org/pdf/PDF/000/546/451/a_unified_approach_to_global_program_optimization.pdf |access-date=2006-11-20 |url-status=live |archive-url=https://web.archive.org/web/20170629213307/http://static.aminer.org/pdf/PDF/000/546/451/a_unified_approach_to_global_program_optimization.pdf |archive-date=2017-06-29}} ([http://portal.acm.org/citation.cfm?id=512945&coll=portal&dl=ACM])</ref>\n<ref name=\"Freiberger_1981_Translators\">{{cite newspaper |title=Program translators do it literally - and sometimes in context |author-first=Paul |author-last=Freiberger |author-link=Paul Freiberger |series=Special section: Computer compatibility |newspaper=[[InfoWorld]] - News For Microcomputer Users |issn=0199-6649 |publisher=[[Popular Computing, Inc.]] |date=1981-10-19 |volume=3 |issue=22 |page=19 |url=https://books.google.com/books?id=Gj0EAAAAMBAJ&pg=PA19&lpg=PA19 |access-date=2020-01-15 |url-status=live |archive-url= |archive-date= |quote=[\u2026] \"Unless you have a translating scheme that takes account of the peculiar idiosyncrasies of the target microprocessor, there is no way that an automatic translator can work,\" explains Daniel Davis, a programmer with [[Digital Research]]. \"You'll end up with direct [[transliteration]]s.\" [\u2026] In spite of all these limitations, progress has been made recently in the development of translators. Most notably, Digital Research has introduced its eight- to 16-bit assembly code translator. Based on research performed by Digital Research president [[Gary Arlen Kildall|Gary Kildall]], the [[XLT86]] appears to offer advances over previously available software translator technology. Like [[Sorcim]]'s [[Sorcim TRANS86|Trans]] and [[Intel]]'s [[Convert&nbsp;86]], Kildall's package translates assembly-language code from an [[8080]] microprocessor to an [[8086]]. However, Kildall has applied a [[global data flow analysis|global flow analysis]] technique that takes into account some of the major drawbacks of other translators. The procedure analyzes the register and flag usage in sections of 8080 code in order to eliminate [[nonessential code]]. According to Digital Research programmer Davis, the algorithm Kildall uses allows the translator to consider the context as it translates the program. Until now, one of the major problems with any translator program has been the inability of the software to do much more than transliteration. If Digital Research's new translator actually advances the technology to the point where context can be considered, then more software translators may proliferate in the microcomputer marketplace.}}</ref>\n<ref name=\"Barry_1982_XLT86\">{{cite newspaper |title=XLT-86, a CP/M utility program by Digital Research |author-first=Tim |author-last=Barry |series=InfoWorld Software Review |newspaper=[[InfoWorld]] - The Newsweekly for Microcomputer Users |issn=0199-6649 |publisher=[[Popular Computing, Inc.]] |date=1982-04-05 |volume=4 |issue=13 |pages=40\u201341, 53 |url=https://books.google.com/books?id=ZjAEAAAAMBAJ&pg=PA40&lpg=PA41 |access-date=2020-01-25 |url-status=live |archive-url= |archive-date= |quote=[\u2026] [[XLT-86]] is an analytical translator program written in [[PL/I-80]]. It reads the entire [[8080]] source program, assembles it to [[machine code]], analyzes the register, memory and flag utilization, and emits an optimized [[8086]] assembly-language program. [\u2026] The program translation proceeds in a five-step process. First, the program is scanned and assembled to produce symbol values and locations. Second, the program structure is analyzed and decomposed into [[basic block]]s. Third, the basic blocks are analyzed to determine [[program flow]] and resource usage. Forth, the [[block (programming)|block structure]] and [[register allocation]] data is gathered into a listing for the user. Fifth, the flow information and source program are used to produce the 8086 source program. [\u2026]}}</ref>\n<ref name=\"Swaine_1982_CPM\">{{cite newspaper |title=Digital Research founder discusses his view of the business |series=Special section: CP/M |editor-first1=Michael |editor-last1=Swaine |editor-link1=Michael Swaine (technical author) |editor-first2=Paul |editor-last2=Freiberger |editor-link2=Paul Freiberger |editor-first3=John Gregory |editor-last3=Markoff |editor-link3=John Gregory Markoff |author-first=Gary Arlen |author-last=Kildall |author-link=Gary Arlen Kildall |date=1982-04-19 |newspaper=[[InfoWorld]] - The Newsweekly for Microcomputer Users |issn=0199-6649 |publisher=[[Popular Computing, Inc.]] |volume=4 |issue=15 |page=23\u201324 |url=https://books.google.com/books?id=YzAEAAAAMBAJ&pg=PA23&lpg=PA23 |access-date=2020-01-17 |url-status=live |archive-url= |archive-date= |quote=[\u2026] Kildall: [\u2026] A year and a half ago I was probably spending 75% of my time on the business and 25% on programming. [[XLT-86]] was a product I was working on at that time, and it took me nine months to do it. That would have been a three-month project if I had been able to concentrate on it. [\u2026]}}</ref>\n<ref name=\"Bunnell_1982_CPM\">{{cite magazine |title=Gary Kildall - The Man Who Created CP/M: CP/M's Creator - An Indepth PC-Exclusive Interview with Software Pioneer Gary Kildall |series=Operating Systems |editor-first1=David Hugh |editor-last1=Bunnell |editor-link=David Hugh Bunnell |editor-first2=Jim |editor-last2=Edlin |author-first=Gary Arlen |author-last=Kildall |author-link=Gary Arlen Kildall |date=June\u2013July 1982 |magazine=[[PC Magazine]] |publisher=[[Software Communications, Inc.]] |issn=<!-- not assigned at this time, but already applied for --> |volume=1 |number=3 |pages=32\u201338, 40<!-- quote taken from page 35 --> |url=https://archive.org/stream/PC-Mag-1982-06/PC-Mag-1982-06_djvu.txt |access-date=2020-01-17 |url-status=live |archive-url= |archive-date= |quote=[\u2026] PC: What are some of the complexities involved in translating a program from [[8080]] to [[8086]] form? [[Gary Arlen Kildall|Kildall]]: Straight [[assembly code translator|translations at the source program level]] you can do pretty much mechanically. For example, an 8080 \"Add immediate 5\" instruction turns into an \"Add AL 5\" on the 8086 \u2014 very straightforward translation of the op codes themselves. The complexity in [[mechanical translation]] comes from situations such as this: The 8080 instruction DAD H takes the HL register and adds DE to it. For the 8086 the equivalent instruction would be something like ADD DX BX, which is fine, no particular problem. You just say the DX register is the same as HL and BX the same as DE. The problem is that the 8086 instruction has a side effect of setting the zero flag, and the 8080 instruction does not. In mechanical translation you end up doing something like saving the flags, restoring the flags, doing some shifts and rotates, and so forth. These add about five or six extra instructions to get the same semantic effect. There are a lot of sequences in 8080 code that produce very strange sequences in 8086 code; they just don't map very well because of flag registers and things of that sort. The way we get software over is a thing called [[XLT-86]]. It's been out six months or so. PC: By \"better\" code do you mean smaller? Kildall: Twenty percent smaller than if you just took every op code and did a straight translation, saving the registers to preserve semantics. PC: How does the size of the translated program compare to the 8080 version? Kildall: If you take an 8080 program, move it over to 86 land and do an XLT-86 translation, you'll find that it is roughly 10 to 20 percent larger. With 16-bit machines it's more difficult to address everything; you get op codes that are a little bit bigger on the average. An interesting phenomenon is that one of the reasons you don't get a tremendous speed increase in the 16-bit world is because you're running more op codes over the data bus. [\u2026]}}</ref>\n<ref name=\"Wharton_1994\">{{Cite journal |url=http://tech-insider.org/personal-computers/research/1994/0801.html |access-date=2016-11-18 |title=Gary Kildall, industry pioneer, dead at 52: created first microcomputer languages, disk operating systems |journal=[[Microprocessor Report]] |publisher=[[MicroDesign Resources Inc.]] (MDR) |author-first=John Harrison |author-last=Wharton |author-link=John Harrison Wharton |volume=8 |number=10 |date=1994-08-01 |url-status=live |archive-url=https://web.archive.org/web/20161118222925/http://tech-insider.org/personal-computers/research/1994/0801.html |archive-date=2016-11-18}}</ref>\n<ref name=\"SPA_1995\">{{cite web |title=SPA Award to Dr. Gary A. Kildall: 1995 SPA Lifetime Achievement Award Winner |date=1995-03-13 |publisher=[[Software Publishers Association]] (SPA) |via=www.digitalresearch.biz |url=https://www.digitalresearch.biz/kildallr.htm |access-date=2019-12-21 |url-status=live |archive-url=http://archive.today/a3iF6 |archive-date=2019-12-21}}</ref>\n<ref name=\"Swaine_1997\">{{cite journal |author-first=Michael |author-last=Swaine |author-link=Michael Swaine (technical author) |date=1997-04-01 |title=Gary Kildall and Collegial Entrepreneurship |journal=[[Dr. Dobb's Journal]] |url=http://www.drdobbs.com/architecture-and-design/gary-kildall-and-collegial-entrepreneurs/184410428 |access-date=2006-11-20 |archive-url=https://web.archive.org/web/20070124184442/http://www.ddj.com/184410428 |archive-date=2007-01-24 |quote=In March, 1995, the [[Software Publishers Association]] posthumously honored [[Gary Kildall|Gary]] for his contributions to the computer industry. They listed some of his accomplishments: [\u2026] In the 1980s, through [[Digital Research, Inc.|DRI]], he introduced a binary recompiler. [\u2026]}}</ref>\n<ref name=\"Laws_2014_IEEE\">{{Cite web |title=Legacy of Gary Kildall: The CP/M IEEE Milestone Dedication |author-first1=Robert |author-last1=Huitt |author-first2=Gordon |author-last2=Eubanks |author-link2=Gordon Eubanks |author-first3=Thomas \"Tom\" Alan |author-last3=Rolander |author-link3=Thomas Alan Rolander |author-first4=David |author-last4=Laws |author-first5=Howard E. |author-last5=Michel |author-first6=Brian |author-last6=Halla |author-first7=John Harrison |author-last7=Wharton |author-link7=John Harrison Wharton |author-first8=Brian |author-last8=Berg |author-first9=Weilian |author-last9=Su |author-first10=Scott |author-last10=Kildall |author-link10=Scott Kildall |author-first11=Bill |author-last11=Kampe |editor-first=David |editor-last=Laws |date=2014-04-25 |location=Pacific Grove, California, USA |type=video transscription |id=CHM Reference number: X7170.2014 |publisher=[[Computer History Museum]] |url=https://archive.computerhistory.org/resources/access/text/2014/06/102746909-05-01-acc.pdf |access-date=2020-01-19 |url-status=live |archive-url= |archive-date= |quote=[\u2026] [[Thomas Alan Rolander|Rolander]]: I mentioned earlier that [[Gary Arlen Kildall|Gary]] liked to approach a problem as an architect. [\u2026] And he would draw the most beautiful pictures of his data structures. [\u2026] And when he finished that [\u2026] and was convinced those data structures were now correct, he would go into just an unbelievable manic coding mode. He would just go for as many as 20 hours a day [\u2026] he was just gone during these periods of time. On a couple of those occasions, when he'd get something running the first time, which could be in the middle of night. And all you who have written software have seen that, for example, that the first time it comes up on the screen, you\u2019ve got to tell somebody. My wife Lori will tell you that I had a couple of those calls in the middle of the night, [[DR LOGO|LOGO]] was one example, [[XLT&nbsp;86]] was another, where he got it running the first time, and he had to have somebody see it. So it didn't matter what time it was, he'd call me, I'd have to come over and see it running. [\u2026]}} [https://ethw.org/Milestones:The_CP/M_Microcomputer_Operating_System,_1974][https://www.youtube.com/watch?v=HO6IPpL0y8g] (33 pages)</ref>\n}}\n\n[[Category:Compilers|*]]\n[[Category:Compiler construction]]\n[[Category:Computer libraries]]\n", "name_user": "JHunterJ", "label": "safe", "comment": "\u2192\u200etop:clean up,typo(s) fixed: layed \u2192 laid", "url_page": "//en.wikipedia.org/wiki/Binary_recompiler"}
